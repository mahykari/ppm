#include <sstream>
#include <cassert>
#include "SemiHonestLiuEtAlProtocol.hh"
#include "StringUtils.hh"

using MonCom = MonitoringComponent;

void LiuEtAlDataHolder::fillGarbledGates(
  const int gateCount,
  QuadraticResidueGroup& group,
  YaoGarbler& garbler)
{
  this->garbledGates.resize(gateCount);
  for (auto i = 0; i < gateCount; i++) {
    BigInt leftInWire = this->inWireLabels[2 * i];
    BigInt rightInWire = this->inWireLabels[2 * i + 1];
    auto outWire = this->outWireLabels[i];

    // Wire labels are once again exponentiated
    // to obtain a pair [L0, L1] for each wire.
    // L0 and L1 correspond to the wire being 0 or 1, respectively.
    BigInt leftLabels[2] = {
      group.exp(leftInWire, this->garblingExponents[0]),
      group.exp(leftInWire, this->garblingExponents[1])
    };
    BigInt rightLabels[2] = {
      group.exp(rightInWire, this->garblingExponents[0]),
      group.exp(rightInWire, this->garblingExponents[1])
    };
    BigInt outLabels[2] = {
      group.exp(outWire, this->garblingExponents[0]),
      group.exp(outWire, this->garblingExponents[1])
    };

    this->garbledGates[i] = garbler.enc(
      { toString(leftLabels[0], 16),
        toString(leftLabels[1], 16) },
      { toString(rightLabels[0], 16),
        toString(rightLabels[1], 16) },
      { toString(outLabels[0], 16),
        toString(outLabels[1], 16) }
    );
  }
}

SemiHonestLiuEtAlProtocol
::SemiHonestLiuEtAlProtocol(
  QuadraticResidueGroup group,
  int gateCount,
  int monitorStateLength,
  int systemStateLength,
  MonitoringComponent role)
  : Protocol<SemiHonestLiuEtAlStage, MonitoringComponent>(role),
    group(group),
    gateCount(gateCount),
    monitorStateLength(monitorStateLength),
    systemStateLength(systemStateLength)
{
  this->currentStage = SemiHonestLiuEtAlStage::FirstSendOutWireLabels;
  this->currentSender = MonCom::Monitor;
  if (role == MonCom::Monitor) {
    this->circuitHolderMemory =
      std::make_unique<LiuEtAlCircuitHolder>();
  } else {
    this->dataHolderMemory =
      std::make_unique<LiuEtAlDataHolder>();
  }
}

void SemiHonestLiuEtAlProtocol::next(std::string message) {
  unsigned outWireCount =
    this->gateCount
    + this->monitorStateLength
    + this->systemStateLength;

  switch (this->currentStage) {
    case SemiHonestLiuEtAlStage::FirstSendOutWireLabels: {
      // Both Monitor and System have something to do in this stage.
      if (this->role == MonCom::System) {
        std::vector<BigInt> outWireLabels;
        std::tie(outWireLabels, message) =
          this->readBigInts(message, outWireCount - 1);
        assert (outWireLabels.size() == outWireCount - 1);
        // Label for the last OutWire is generated by System;
        // a random group element suffices for this purpose.
        outWireLabels.push_back(this->group.randomGenerator());
        this->dataHolderMemory->outWireLabels = outWireLabels;
      }
      // Role is not MonCom::System => MonCom::Monitor
      else {
        auto circMem = this->circuitHolderMemory.get();
        auto inWireCount = 2 * this->gateCount;
        circMem->inWireKeys.resize(inWireCount);
        for (auto i = 0; i < inWireCount; i++)
          circMem->inWireKeys[i] = this->group.randomExponent();
      }
      this->currentStage = SemiHonestLiuEtAlStage::FirstSendInWireLabels;
      this->currentSender = MonCom::Monitor;
      break;
    }

    case SemiHonestLiuEtAlStage::FirstSendInWireLabels: {
      if (this->role == MonCom::System) {
        auto dataMem = this->dataHolderMemory.get();
        std::vector<BigInt> inWireLabels;
        size_t inWireCount = 2 * this->gateCount;
        std::tie(inWireLabels, message) =
          this->readBigInts(message, inWireCount);
        assert (inWireLabels.size() == inWireCount);
        printf("D: received %d ingoing wire labels\n", inWireCount);

        dataMem->inWireLabels = inWireLabels;
        dataMem->garblingExponents[0] = this->group.randomExponent();
        dataMem->garblingExponents[1] = this->group.randomExponent();
        // Having In- and OutWire labels and garbling exponents,
        // System can compute the garbled tables.
        // REMINDER: the very last OutWire label is generated by System,
        // and is already stored in dataMem->outWireLabels.
        dataMem->fillGarbledGates(this->gateCount, this->group, this->garbler);
      }
      // Monitor has nothing to do in this stage.
      this->currentStage =
        SemiHonestLiuEtAlStage::FirstSendGarbledTables;
      this->currentSender = MonCom::System;
      break;
    }

    case SemiHonestLiuEtAlStage::FirstSendGarbledTables: {
      // Since this is the first round,
      // Monitor should obtain the labels
      // for some input wires via OT;
      // so, circuit evaluation takes place after OT.
      if (this->role == MonCom::Monitor) {
        // Message is formatted as
        // EncGG1 EncGG2 ... EncGGn
        // + OutLabel1 OutLabel2
        // + DriverLabel1 ... DriverLabel{systemStateLength}

        auto circMem = this->circuitHolderMemory.get();

        // Part 1: EncGG1 EncGG2 ... EncGGn
        std::tie(circMem->garbledGates, message) =
          this->readGarbledTables(message, this->gateCount);
        assert (circMem->garbledGates.size() == this->gateCount);

        // Part 2: OutLabel1 OutLabel2
        std::vector<BigInt> outputLabels;
        std::tie(outputLabels, message) =
          this->readBigInts(message, 2);
        assert (outputLabels.size() == 2);
        std::copy_n(outputLabels.begin(), 2, circMem->outputLabels.begin());

        // Part 3: DriverLabel1 ... DriverLabel{systemStateLength}
        std::tie(circMem->evaluatedOutWireLabels, message) =
          this->readBigInts(message, this->systemStateLength);
        assert (
          circMem->evaluatedOutWireLabels.size() == this->systemStateLength);
        circMem->evaluatedOutWireLabels.resize(outWireCount);
      }
      this->currentStage = SemiHonestLiuEtAlStage::FirstOT;
      this->currentSender = MonCom::Monitor;
      break;
    }

    case SemiHonestLiuEtAlStage::FirstOT: {
      if (this->OTCounter == this->monitorStateLength) {
        // Having received the garbled tables
        // and driver labels for circuit inputs,
        // Monitor can now evaluate the circuit.
        if (this->role != MonCom::Monitor)
          break;
        auto circMem = this->circuitHolderMemory.get();

        // First, we should unshuffle the circuit,
        // so that we can evaluate gates in topological order.
        std::vector<Driver*> unshuffledCircuit;
        assert (circMem->circuit->size() == circMem->shuffledCircuit.size());
        unshuffledCircuit.resize(circMem->circuit->size());
        for (auto i = 0; i < circMem->circuit->size(); i++) {
          Driver* shuffledDriver = circMem->shuffledCircuit[i];
          unshuffledCircuit[shuffledDriver->id] = shuffledDriver;
        }
        auto offset = this->monitorStateLength + this->systemStateLength;
        // All gates can be evaluated
        // using labels picked by Monitor (in a previous stage).
        for (auto i = 0; i < gateCount; i++) {
          Gate* gate = static_cast<Gate*> (unshuffledCircuit[offset + i]);
          auto leftLabel = this->group.exp(
            circMem->evaluatedOutWireLabels[gate->inputLeft],
            circMem->inWireKeys[2 * gate->id]);
          auto rightLabel = this->group.exp(
            circMem->evaluatedOutWireLabels[gate->inputRight],
            circMem->inWireKeys[2 * gate->id + 1]);
          auto outLabel = this->garbler.dec(
            toString(leftLabel, 16),
            toString(rightLabel, 16),
            circMem->garbledGates[i]
          );
          circMem->evaluatedOutWireLabels[gate->id] = BigInt(outLabel, 16);
        }
        // To get the last output as a boolean value,
        // we must use the labels sent by System.
        auto outputLabel = circMem->evaluatedOutWireLabels.back();
        circMem->isDone = outputLabel == circMem->outputLabels[0];
        this->currentStage = SemiHonestLiuEtAlStage::Continue;
        this->currentSender = MonCom::Monitor;
      } else {
        this->OTCounter++;
        // TODO: implement OT
        this->currentStage = SemiHonestLiuEtAlStage::FirstOT;
        this->currentSender = MonCom::System;
      }
      break;
    }

    case SemiHonestLiuEtAlStage::SendGarbledTables:
      if (this->role == MonCom::Monitor) {
        abort();
      }
      this->currentStage = SemiHonestLiuEtAlStage::Continue;
      this->currentSender = MonCom::Monitor;
    case SemiHonestLiuEtAlStage::Continue:
      bool isDone;
      if (this->role == MonCom::System) {
        std::stringstream ss(message);
        ss >> isDone;
      } else {
        isDone = this->circuitHolderMemory->isDone;
      }
      this->currentStage = isDone ?
        SemiHonestLiuEtAlStage::Done :
        SemiHonestLiuEtAlStage::SendGarbledTables;
      break;
    default: break;
  }
}

std::string SemiHonestLiuEtAlProtocol::currentMessage() {
  auto outWireCount =
    this->gateCount
    + this->monitorStateLength
    + this->systemStateLength;
  switch (this->currentStage) {
    case SemiHonestLiuEtAlStage::FirstSendOutWireLabels:
      if (this->role == MonCom::Monitor) {
        auto circMem = this->circuitHolderMemory.get();
        circMem->outWireLabels.resize(outWireCount);
        // Labels stored in outWireLabels are sorted by driver ID;
        // i.e., outWireLabels[i] corresponds to circMem->circuit->drivers[i].
        // Monitor does not assign a label to the last OutWire.
        for (auto i = 0; i < outWireCount - 1; i++)
          circMem->outWireLabels[i] = this->group.randomGenerator();

        // Monitor shuffles the circuit before sending any labels to System.
        // Note that this shuffling does not affect drivers
        // corresponding to circuit inputs or outputs.
        circMem->shuffledCircuit = circMem->circuit->shuffle();
        std::stringstream ss;
        for (auto i = 0; i < outWireCount - 1; i++) {
          auto gateId = this->circuitHolderMemory
            ->shuffledCircuit[i]->id;
          // Since the last OutWire is not labelled yet,
          // it should also be skipped at this stage.
          if (gateId == outWireCount - 1)
            continue;
          auto label = this->circuitHolderMemory
            ->outWireLabels[gateId];
          ss << toString(label, 16) << ' ';
        }
        return ss.str();
      }
    case SemiHonestLiuEtAlStage::FirstSendInWireLabels:
      if (this->role == MonCom::Monitor) {
        std::stringstream ss;
        // First elements of the shuffled circuit are input wires.
        auto circMem = this->circuitHolderMemory.get();
        auto offset = this->monitorStateLength + this->systemStateLength;
        for (auto i = 0; i < this->gateCount; i++) {
          auto gate = static_cast<Gate*> (circMem->shuffledCircuit[offset + i]);
          auto leftKey = circMem->inWireKeys[2 * gate->id];
          auto rightKey = circMem->inWireKeys[2 * gate->id + 1];

          auto leftDriverLabel = circMem->outWireLabels[gate->inputLeft];
          auto rightDriverLabel = circMem->outWireLabels[gate->inputRight];

          auto leftInWireLabel = this->group.exp(leftDriverLabel, leftKey);
          auto rightInWireLabel = this->group.exp(rightDriverLabel, rightKey);
          ss << toString(leftInWireLabel, 16) << ' '
             << toString(rightInWireLabel, 16) << ' ';
        }
        return ss.str();
      }
    case SemiHonestLiuEtAlStage::FirstSendGarbledTables:
      if (this->role == MonCom::System) {
        std::stringstream ss;
        for (auto i = 0; i < this->gateCount; i++) {
          auto gg = this->dataHolderMemory->garbledGates[i];
          for (auto j = 0; j < 4; j++)
            ss << gg[j] << ' ';
        }
        return ss.str();
      }
    case SemiHonestLiuEtAlStage::FirstOT:
      // ...
    case SemiHonestLiuEtAlStage::SendGarbledTables:
      if (this->role == MonCom::System) {
        std::stringstream ss;
        for (auto i = 0; i < this->gateCount; i++) {
          auto gg = this->dataHolderMemory->garbledGates[i];
          for (auto j = 0; j < 4; j++)
            ss << gg[j] << ' ';
        }
        return ss.str();
      }
    case SemiHonestLiuEtAlStage::Continue:
      // ...
    case SemiHonestLiuEtAlStage::Done:
      // ...
    default: return "";
  }
}

bool SemiHonestLiuEtAlProtocol::isOver() {
  return this->currentStage == SemiHonestLiuEtAlStage::Done;
}

std::tuple<std::vector<GarbledGate>, std::string>
SemiHonestLiuEtAlProtocol::readGarbledTables(
  std::string message, int count)
{
  std::vector<GarbledGate> garbledGates;
  std::stringstream ss(message);
  for (auto i = 0; i < count; i++) {
    GarbledGate gate;
    for (auto j = 0; j < 4; j++)
      ss >> gate[j];
    garbledGates.push_back(gate);
  }
  auto remaining = ss.str().substr(ss.tellg());
  return { garbledGates, remaining };
}

std::tuple<std::vector<BigInt>, std::string>
SemiHonestLiuEtAlProtocol::readBigInts(
  std::string message, int count)
{
  std::stringstream ss(message);
  std::vector<BigInt> bigInts;
  while (not ss.eof()) {
    BigInt n;
    ss >> n;
    bigInts.push_back(n);
  }
  auto remaining = ss.str().substr(ss.tellg());
  return { bigInts, remaining };
}
